{Application 'CentralMenu' logic file generated by CSPro }
PROC GLOBAL

  FILE      piffile;                       { data entry PFF file for the application }
  FILE      fromcheck;                      { to read file generated by StructureCheck        }
  FILE      state;                         { Remembers the cluster and supervisor from one run to the next }
  FILE      NewClust;                      { file handler with clusters that arrived to the central office }
  FILE      ClosedClust;                   { used to display clusters closed in the filed that arrived to the central office }

  alpha(500) TheCommand;
  alpha(250) cmdline;                      { Used as a command line or to read strings }
  alpha(80)  CSPro;                        { CSPro executables directory }
  alpha(20)  app;                          { application name }
  alpha(8)   opid;                         { operator ID }
  alpha(80)  wrkprj, superv, backup;       { directories }
  alpha(80)  lookup, reports, work, rawdata, final, accepted;
  alpha(80)  entry, central, temp, contrl;
  alpha(15)  xparaux;
  alpha(90)  chkfile;
  alpha(12)  executable;
  alpha(40)  fname;                        { filenames for various files }
  alpha(15)  xparamet;                     {   1-2 Interviewer,           3-4 supervisor,
                                                 5 modify central office    6 revisitar hogar
                                                 7 modificar hogar          8 caso salvado parcialmente
                                                 9 entrar peso y talla
                                             10-11 Dwelling number      12-13 Household number
                                             14-15 Respondent line number }
  alpha(3)   xsupnum;                      { Supervisor }
  alpha(3)   xcluster;                     { Cluster number }
  alpha(50)  heading;
  alpha(30)  sname;						                  { Supervisor's name }
  alpha(11)  xstate;                       { Used to remember the cluster and supervisor numbers }
  alpha(40)  strtail;                      { used to customize the report on clusters arrived to central office }
  alpha(10)  datestr, timestr;             { used to gget dates and time coming from the filed by utility GetFiles }
  alpha(25)  apptoday;					   { app name with today's date added }
  alpha(8)   today;						   { today's date }

  array codes(300);
  array alpha(30) labels(300);

  array intvwcode(200);                    { to store interviewers }
  array intvwrole(200);
  array intvwteam(200);
  array intvwsex(200);
  array alpha(30) intvwname(200);

  numeric steam;
  numeric exist, action, filerep, x, i, j, y, totintvw, test;

// ----- FTP server credentials
string		ftp_server = "xxx.xxx.xxx.xxx";
string		ftp_user = "User";
string		ftp_password = "Password";

// CSweb
string      csw_server = "xxx.xxx.xxx.xxx";
string		csw_user = "User";
string		csw_password = "Password"; 
string		ftp_root = "/CoreFTF/";				{ this filename is in lowercase - FTP server }


  function receive_data()

	close(clusters);
	close(interv);
	filedelete("/Lookup/interv.dat.idx");
	filedelete("/Lookup/clusters.dat.idx");

//  if !syncconnect( Dropbox ) then
//  if !syncconnect( FTP,ftp_server,ftp_user,ftp_password ) then 
    if !syncconnect( CSWeb,csw_server,csw_user,csw_password ) then 
		errmsg(121);
		receive_data = 0; 
    else
      syncfile( GET, concat(ftp_root,"./CODATA/RECEIVED/A*.dat"),"../CODATA/RECEIVED/");
      syncfile( GET, concat(ftp_root,"./CODATA/RECEIVED/G*.dat"),"../CODATA/RECEIVED/");
      syncfile( GET, concat(ftp_root,"./CODATA/RECEIVED/O*.dat"),"../CODATA/RECEIVED/");
      syncfile( GET, concat(ftp_root,"./CODATA/RECEIVED/C*.dat"),"../CODATA/RECEIVED/");
      syncfile( GET, concat(ftp_root,"./CODATA/AREA/*.dat"),"../CODATA/AREA/");
      syncfile( GET, concat(ftp_root,"./CODATA/AREA/*.kml"),"../CODATA/AREA/");
      syncfile( GET, concat(ftp_root,"./ENTRY/*.*"),"../ENTRY/");
      syncfile( GET, concat(ftp_root,"./DICTS/*.*"),"../DICTS/");
      syncfile( GET, concat(ftp_root,"./CENTRAL/*.*"),"../CENTRAL/");
      syncfile( GET, concat(ftp_root,"./LOOKUP/*.*"),"../LOOKUP/");
   
	  syncdisconnect();
		errmsg(120);
		receive_data = 1;
    endif;
		
  end;	


  function clean_labels()
    do i = 0 while i <= 300
      codes(i) = notappl;
      labels(i) = "";
    enddo;
  end;

  { runs an application from a given directory }
  function runpff( CSmod, alpha(80) directory );
    if     CSmod in 1,4 then executable = "CSBatch.exe"
    elseif CSmod = 2 then executable = "CSEntry.exe"
    elseif CSmod = 3 then executable = "CSSort.exe"
    endif;
    if CSmod = 4 then 
      { Using single quotes instad of double quotes as double quotes are needed in the string generated }
      { Field check tables - if run in CSPro, MUST be done in version 6.3 in order for TablesUnicode.exe to work - otherwise, tables could be written and produced in another software }
      TheCommand = concat( '"C:\Program Files (x86)\CSPro 6.3\', strip(executable), '" "', strip(directory), '\', strip(app), '.pff"' );
      ExecSystem( strip(TheCommand), maximized, wait );
    else
      { Using single quotes instad of double quotes as double quotes are needed in the string generated }
      TheCommand = concat( '"', strip(cspro), '\', strip(executable), '" "', strip(directory), '\', strip(app), '.pff"' );
      ExecSystem( strip(TheCommand), maximized, wait );
	endif;
  end;

  { Views a text file }
  function textview( alpha(80) directory, alpha(32) fileview );
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    TheCommand = concat( '"', strip(cspro), '\TextView.exe" "', strip(directory), '\', strip(fileview), '"' );
    ExecSystem( strip(TheCommand), maximized, wait );
  end;

  { checks if a cluster has already been closed or not }
  function clustopen()
    open( CONTROL );
    x = 1;
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      x = 0;
      errmsg( 007, CSAMPLE );
    elseif CACCEPT then
      errmsg( "Cluster %d already accepted", CSAMPLE );
      x = accept( "Accept Cluster again", "Yes", "No" );
      if x = 2 then x = 0 endif;
    endif;
    close( CONTROL );
    clustopen = x;
  end;

  { checks a cluster status before a modification to know if: }
  { 1-cluster was already closed                              }
  { 2-cluster already passed secondary editing                }
  { 3-cluster was already accepted                            }
  function valstatus( xtype )
  { xtype 1 - Modify for structural problems }
  {       2 - Modify for secondary editing   }
  {       3 - Close cluster                  }
    open( CONTROL );
    x = 0;
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      x = errmsg( 007, CSAMPLE );
    { for either structure/secondary-edting/close but cluster aleary closed }
    elseif CFINDATE then
      x = errmsg( 008, CSAMPLE );
    { modify for structure but cluster already passed secondary editing }
    elseif xtype = 1 & CEDIT(1) then
      x = errmsg( 009, CSAMPLE );
    { modify for structure but cluster already accepted }
    elseif xtype = 1 & CACCEPT then
      x = errmsg( 013, CSAMPLE );
    { close cluster but not have been accepted yet }
    elseif xtype = 3 & !CACCEPT then
      x = errmsg( 014, CSAMPLE );
    { close cluster but not have been passed by secondary editing }
    elseif xtype = 3 & !CEDIT(1) then
      x = errmsg( 017, CSAMPLE );
    endif;
    close( CONTROL );
    valstatus = ( x = 0 );
  end;

  { updates the control file after it is accepted, runs secondary editing or it is closed }
  function updtctrl( xtype )
  { xtype - 1 updates cluster accepted      }
  {         2 updates secondary editing     }
  {         3 cluster is declared as closed }
    open( CONTROL );
    CSAMPLE = WCLUSTER;
    if !loadcase( CONTROL, CSAMPLE ) then
      errmsg( 007, CSAMPLE );
    elseif xtype = 0 then 
      CDATEBEG = sysdate();
      writecase( CONTROL );
    elseif xtype = 1 then                      { update cluster accepted date }
      CACCEPT = sysdate();
      writecase( CONTROL );
    elseif xtype = 2 then                      { update inconsistencies }
      do i = 1 while i <= 5 by 1
        if CEDIT(i) = 0 then
          CEDIT(i) = sysdate();
          writecase( CONTROL );
          break;
        endif;
      enddo;
    elseif xtype = 3 then                      { update close cluster }
      if CACCEPT = 0 then
        errmsg( 014, CSAMPLE );
      elseif CEDIT(1) = 0 then
        errmsg( 017, CSAMPLE );
      elseif CFINDATE <> 0 then
        errmsg( 008, CSAMPLE );
      else
        CFINDATE = sysdate();
        writecase( CONTROL );
        errmsg( 080, CSAMPLE );
      endif;
    endif;
    close( CONTROL );
  end;

  { writes pif files headings }
  function InitPFF( CSmod );
    if     CSmod = 1 then executable = "Batch"
    elseif CSmod = 2 then executable = "Entry"
    elseif CSmod = 3 then executable = "Sort"
    endif;
    setfile( piffile, concat( strip(central), "\", strip(app), ".pff" ) );
    FileDelete( piffile );
    FileWrite( piffile, "[Run Information]" );
    FileWrite( piffile, "Version=CSPro 7.2" );
    FileWrite( piffile, concat("AppType=", strip(executable) ) );
  end;

  { generates the PFF file needed to run application StructureCheck.bch.  This application  }
  { checks for structural problems in the cluster as well as to update the control file     }
  function StructureCheck( dir )
  {     dir - 1 to list and check clusters from raw directory }
  {           2 to check clusters from FINAL directory           }
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(central), "\",  strip(app), ".bch" ) );
    if dir = 1 then
      FileWrite( piffile, concat( "InputData=",  strip(central), "\Nulldata", ".DAT" ) );    
    elseif dir = 2 then
      FileWrite( piffile, concat( "InputData=", strip(final),  "\A", strip(xcluster), ".DAT" ) );
    endif;
    FileWrite( piffile, concat( "Listing=",     strip(central), "\",  strip(app), ".lst" ) );
    FileWrite( piffile, concat( "WriteData=",   strip(central), "\",  strip(app), ".wrt" ) );

    FileWrite( piffile, "[ExternalFiles]" ); 
    FileWrite( piffile, concat( "CFTF=",  strip(rawdata), "\A", strip(xcluster), ".DAT" ) );
    FileWrite( piffile, concat( "CONTROL=", strip(lookup), "\CONTROL.DAT" ) );
    FileWrite( piffile, concat( "CLUSTERS=", strip(lookup), "\CLUSTERS.DAT" ) );
    FileWrite( piffile, concat( "SAMPSEL=",  strip(lookup), "\SAMPSEL.DAT" ) );
    FileWrite( piffile, concat( "CTRL_CLUSTER=",  strip(lookup), "\CTRL_CLUSTER.DAT" ) );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, concat( "Parameter=", edit("9", (dir = 1) ), strip(xcluster) ) );  { 1-first time, 0-listing cluster }
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    FileWrite( piffile, "ListingWidth=120" );
    close( piffile );
  end;

  { constructs PPF file to sort the control file by supervisor (SORTCONT) }
  function sortcont()
    InitPFF(3);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(central), "\", strip(app), ".ssf" ) );
    FileWrite( piffile, concat( "InputData=",   strip(lookup),  "\CONTROL.DAT" ) );
    FileWrite( piffile, concat( "OutputData=",  strip(lookup),  "\CONTSORT.DAT" ) );
    FileWrite( piffile, concat( "Listing=",     strip(central), "\", strip(app), ".lst" ) );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { constructs PPF file to sort household or individual data   }
  { sorting data is specially important for women in order to  }
  { check that children are not declared by more than one      }
  { woman in the same household                                         }
  function sortdata( xtype )
  { xtype - 1 to sort household data }
  {         2 to sort women's data   }
    InitPFF(3);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=",  strip(central), "\", strip(app), ".ssf" ) );

    if xtype = 1 then 
      FileWrite( piffile, concat( "InputData=", strip(rawdata), "\A", strip(xcluster), ".DAT" ) );
      FileWrite( piffile, concat( "OutputData=", strip(accepted),  "\A", strip(xcluster), ".DAT" ) );
    elseif xtype = 2 then 
      FileWrite( piffile, concat( "InputData=", strip(accepted), "\A", strip(xcluster), ".DAT" ) );
      FileWrite( piffile, concat( "OutputData=", strip(final),  "\A", strip(xcluster), ".DAT" ) );
    endif;
    
    FileWrite( piffile, concat( "Listing=", strip(central), "\", strip(app), ".lst" ) );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { generates the PFF file for the data collection status report application }
  function makestat( whatfile )
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(central), "\",  strip(app), ".bch" ) );
//    if whatfile = 1 then
      FileWrite( piffile, concat( "InputData=", strip(lookup),  "\CONTROL.DAT" ) );
  {  else
      FileWrite( piffile, concat( "InputData=", strip(lookup),  "\CONTSORT.DAT" ) );
    endif;} { !! TO DO GD - adjust if providing more than one status report }
    FileWrite( piffile, concat( "Listing=",     strip(central), "\",  strip(app), ".lst" ) );
    FileWrite( piffile, concat( "WriteData=",   strip(reports),  "\",  strip(app), ".wrt" ) );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, concat( "INTERV=",  strip(lookup),  "\INTERV.DAT" ) );
    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=OnError" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;

  { generates the PFF file check field tables }
  function FieldChk()
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(central), "\",  strip(app), ".bch" ) );
    FileWrite( piffile, concat( "InputData=",   strip(reports),  "\ALLDATA.DAT" ) );
    FileWrite( piffile, concat( "Listing=",     strip(central), "\",  strip(app), ".lst" ) );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=Never" );
    FileWrite( piffile, "ViewResults=No" );
    close( piffile );
  end;


  { generates the PFF file for the household secondary edit application }
  function secondaryediting()
    InitPFF(1);
    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(central), "\",  strip(app), ".bch" ) );
    FileWrite( piffile, concat( "InputData=",   strip(accepted),  "\A", strip(xcluster), ".DAT" ) );
    FileWrite( piffile, concat( "Listing=",     strip(central), "\",  strip(app), ".lst" ) );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, concat( "WEIGHTS=",   strip(lookup),  "\weights.DAT" ) );
    FileWrite( piffile, concat( "CONTROL=",   strip(lookup),  "\control.DAT" ) );

    FileWrite( piffile, "[Parameters]" );
    FileWrite( piffile, "ViewListing=Always" );
    FileWrite( piffile, "ViewResults=Yes" );
    FileWrite( piffile, "ListingWidth=120" );
    close( piffile );
  end;

  { constructs PPF file for household and individual data entry }
  function genpff( questype )
    InitPFF(2);
    FileWrite( piffile, "[DataEntryInit]" );
    FileWrite( piffile, concat( "OperatorID=", strip(opid) ) );
    FileWrite( piffile, "Lock=Add, Verify" );
    FileWrite( piffile, "Fullscreen=No" );
    FileWrite( piffile, "NoFileOpen=Yes" );

    FileWrite( piffile, "[Files]" );
    FileWrite( piffile, concat( "Application=", strip(entry), "\", strip(app), ".ent" ) );
    { TEMP directory where data is stored, set before executing the option }
    FileWrite( piffile, concat( "InputData=", strip(temp), "\A", strip(xcluster), ".DAT" ) );
    FileWrite( piffile, concat( "Listing=",   strip(temp), "\CFTF.lst" ) );

    FileWrite( piffile, "[ExternalFiles]" );
    FileWrite( piffile, concat( "CTRL_HH=", strip(contrl), "\CT", strip(xcluster), ".DAT"));
    FileWrite( piffile, concat( "OTHERS=",   strip(temp),   "\O", strip(xcluster), ".DAT" ) );
    FileWrite( piffile, concat( "HH_GPS=",   strip(temp),   "\G", strip(xcluster), ".DAT" ) );
    FileWrite( piffile, concat( "CLUSTERS=", strip(lookup), "\CLUSTERS.DAT"));

    FileWrite( piffile, "[Parameters]" );
    
    { customize parameters for different types of data entry modes }
    xparamet[1:3] = xcluster;
    xparamet[4:10] = "0000000000";
    xparamet[14:1]  = "2";                    { Modify by central office }
    xparamet[15:1] = "1";                    { to run modify mode }
    FileWrite( piffile, concat( "Parameter=", xparamet ) );
    close( piffile );
  end;

  { prepares files to view later with ListView }
  function prepfiles( alpha(32) file1, alpha(32) file2, alpha(32) file3, copyto )
    { Using single quotes instead of double quotes as double quotes are needed in the string generated }
    if copyto = 1 then
      FileConcat( concat( strip(reports),  "\", strip(file3) ),     { destination }
                  concat( strip(central), "\", strip(file1) ),     { file 1 to concatenate }
                  concat( strip(central), "\", strip(file2) ) );   { file 2 to concatenate }
    else
      FileConcat( concat( strip(central), "\", strip(file3) ),     { destination }
                  concat( strip(central), "\", strip(file1) ),     { file 1 to concatenate }
                  concat( strip(central), "\", strip(file2) ) );   { file 2 to concatenate }
    endif;
  end;

  { check that files for households and individuala exist in a given directory }
  function files_in( alpha(50) directory )
    exist = 0;
    if FileExist( concat( strip(directory), "\A", strip(xcluster), ".DAT" ) ) then
      exist = 1;
    endif;
    files_in = exist;
  end;

  { copy files from rawdata directory to closed directory      }
  { to copy household and individual data it uses sort instead.}
  { Sorting data is specially important for women in order to  }
  { check that children are not declared by more than one      }
  { woman in the same household                                }
  function copyctrl( xtype )
    { sorts household data and outputs it to directory CLOSED }
    if xtype = 1 then 
      app = "SORTDATA1";
      sortdata( xtype );
      runpff( 3, central );
    { sorts individual data and outputs it to directory CLOSED }
    { copy others }
      FileCopy( concat( strip(rawdata), "\G", strip(xcluster), ".DAT" ), strip(accepted) );    { GPS }
      FileCopy( concat( strip(rawdata), "\O", strip(xcluster), ".DAT" ), strip(accepted) );    { others }
      FileCopy( concat( strip(rawdata), "\T", strip(xcluster), ".NOT" ), strip(accepted) );    { notes }
    elseif xtype = 2 then 
      app = "SORTDATA2";
      sortdata( xtype );
      runpff( 3, central );
    { sorts individual data and outputs it to directory CLOSED }
    { copy others }
      FileCopy( concat( strip(accepted), "\G", strip(xcluster), ".DAT" ), strip(final) );    { GPS }
      FileCopy( concat( strip(accepted), "\O", strip(xcluster), ".DAT" ), strip(final) );    { others }
      FileCopy( concat( strip(accepted), "\T", strip(xcluster), ".NOT" ), strip(final) );    { notes }
    endif;
  end;

  { finds the drive letter where the flash memory is located }
  function searchdrive( carpet )
    numeric found = 0;
    do i = 1 while i <= 4 & !found
      if carpet = 1 then
        backup = concat( "EFGH"[i:1], ":\RAW" );
      elseif carpet = 2 then
        backup = concat( "EFGH"[i:1], ":\ACCEPTED" );
      else
        backup = concat( "EFGH"[i:1], ":\CLOSED" );
      endif;
      if FileExist( strip(backup) ) then
        found = 1;
      endif;
    enddo;
    searchdrive = found;
  end;

  { back-ups data to hard drive and memory flash }
  function backupf()
    { back-up closed directory }
    if !searchdrive( 1 ) | !FileExist( strip(backup) ) then
      errmsg( 070, strip(backup) );
      searchdrive( 1 );
    endif;
    if FileExist( strip(backup) ) then
      FileCopy( concat( strip(rawdata),  "\*.* " ), strip(backup) );
      errmsg( "Completed data backup in RAW directory to %s directory", backup );
    else
      errmsg( 071, strip(backup) );
    endif;
    { back-up rawdata directory }
    if !searchdrive( 2 ) | !FileExist( strip(backup) ) then
      errmsg( 070, strip(backup) );
      searchdrive( 2 );
    endif;
    if FileExist( strip(backup) ) then
      FileCopy( concat( strip(accepted), "\*.* " ), strip(backup) );
      errmsg( "Completed data backup in ACCEPTED directory to %s directory", backup );
    else
      errmsg( 071, strip(backup) );
    endif;
    { back-up closed directory }
    if !searchdrive( 3 ) | !FileExist( strip(backup) ) then
      errmsg( 070, strip(backup) );
      searchdrive( 3 );
    endif;
    if FileExist( strip(backup) ) then
      FileCopy( concat( strip(final),  "\*.* " ), strip(backup) );
      errmsg( "Completed data backup in CLOSED directory to %s directory", backup );
    else
      errmsg( 071, strip(backup) );
    endif;
  end;

  { collpase all households into one file }
  function collapse()
    FileConcat( concat( strip(reports),  "\ALLDATA.DAT" ),      { destination }
                concat( strip(accepted), "\A???.dat" ) );      { from }
  end;

  { collpase all individuals into one file }

  { update clusters rawdata from the filed in directory Recivdir }
  function UpdateControlArrived()
    fname  = concat( strip(central), "\Clusters.txt" );
    SetFile( NewClust, strip(fname) );
    if FileExist( strip(fname) ) then
      FileDelete( strip(fname) );
    endif;
    { getfiles is a utility that searches for file names given in a mask and outputs one line for each file found }
    { It uses the following command line: "getfiles.exe <input mask within a path> <output file>"                 }
    ExecSystem( concat( strip(central), "\others\GetFiles.exe ", strip(rawdata), "\A??????.dat ", strip(fname), " moddate" ), wait );    { !! check file name conventions }
    open( CONTROL );
    while FileRead( NewClust, cmdline ) do
      CSAMPLE = tonumber( cmdline[2:3] );                                                                               { !! check file name lenght }
      if loadcase(CONTROL, CSAMPLE) & !CDATEBEG then
        CDATEBEG = sysdate( "YYMMDD" );
        writecase( CONTROL );
      endif;
    enddo;
    close( CONTROL );
  end;

  { finds closed clusters in the filed that arrived to the central office }
  function FindClosedClusters()
    numeric arrivedclosed = 0, newdate = 0, olddate;
    fname  = concat( strip(central), "\Clusters.txt" );
    SetFile( NewClust, strip(fname) );
    if FileExist( strip(fname) ) then
      FileDelete( strip(fname) );
    endif;
    setfile( ClosedClust, concat( strip(central), "\CLOSEDCLUST.TXT" ) );
    FileWrite( ClosedClust, "LIST OF CLUSTERS CLOSED IN THE FIELD AND PRESENT IN DIRECTORY 'RAW'" );
    FileWrite( ClosedClust, "------------------------------------------------------------------------------" );
    { getfiles is a utility that searches for file names given in a mask and outputs one line for each file found }
    { It uses the following command line: "getfiles.exe <input mask within a path> <output file>"                 }
    ExecSystem( concat( strip(central), "\others\GetFiles.exe ", strip(rawdata), "\A???.dat ", strip(fname), " moddate" ), wait );    { !! check file name conventions }
    open( CONTROL );
    while FileRead( NewClust, cmdline ) do
      { extract and convert dates output by GetFiles }
      j = length( strip(cmdline) );
      x = pos( ";", cmdline );
      y = pos( ";", cmdline[x+1:j-x] );
      datestr = cmdline[x+1:y-1];                    { date as a string }
      timestr = cmdline[x+y+1:j-y];                  { time as a string }
      newdate = tonumber( strip(datestr) );
      CSAMPLE = tonumber( cmdline[2:3] );
      if loadcase(CONTROL, CSAMPLE) & !CACCEPT | newdate > 20000000+CACCEPT then
        strtail = " ";
        if CFINDATE then
          olddate = 20000000+CFINDATE;
          strtail = concat( "but already closed on: ", edit("99999999", olddate) );
        elseif CACCEPT then
          olddate = 20000000+CACCEPT;
          strtail = concat( "but already accepted on: ", edit("99999999", olddate) );
        endif;
        FileWrite( ClosedClust, concat( "Cluster: ", edit("9999", CSAMPLE), " Arrived on: ", datestr, timestr, strtail )  );
        arrivedclosed = 1;
      endif;
    enddo;
    close( CONTROL );
    close( ClosedClust );
    if arrivedclosed then
      textview( strip(central), "CLOSEDCLUST.TXT" );
    endif;
  end;

{PROC WSUPERV
onfocus
  { load array with supervisors }
  clean_labels();
  i = 0;
  do j = 1 while j <= totintvw
    if intvwrole(j) = 2 then { supervisor }
      codes(i)  = intvwcode(j);
      labels(i) = intvwname(j);
      i = i + 1;
    endif;
  enddo;
  setvalueset(@getsymbol(), codes, labels);

  if special(visualvalue($)) & tonumber(xsupnum) <> 0 then
    $ = tonumber(xsupnum)
  endif;

postproc
  do j = 1 while j <= totintvw & intvwcode(j) <> $ enddo;
  if j <= totintvw then
    steam = intvwteam(j);
    sname = intvwname(j);
  else
    errmsg( "Failed to get team number");
  endif;

  skip to WCLUSTER;
}
PROC FL_MENU
PreProc

  CSPro  = PathName( CSPro );
  backup = "E:";                         { needs directories: RAW and ACCEPTED and CLOSED, function searchdrive() will change it if necessary }

  { Operator ID }
  opid="Anyone";                         { this could be an ID set on each machine }

  wrkprj  = "C:\CFTF";
  entry   = concat( strip(wrkprj), "\ENTRY" );    { interviewer programs }
  superv  = concat( strip(wrkprj), "\SUPERVISOR" );   { supervisor programs }
  rawdata = concat( strip(wrkprj), "\CODATA\RECEIVED" );  { data downloaded from FTP/Dropbox }
  accepted = concat( strip(wrkprj), "\CODATA\ACCEPTED" );  { data downloaded from FTP/Dropbox }
  central = concat( strip(wrkprj), "\CENTRAL" );  { central office programs }
  final  = concat( strip(wrkprj), "\CODATA\FINAL" );    { to store final data after being edited }
  reports  = concat( strip(wrkprj), "\REPORTS" );  { to store all reports }
  lookup  = concat( strip(wrkprj), "\LOOKUP" );      { reference directory for clusters, sample and teams files }
  contrl = concat( strip(wrkprj), "\CODATA\CONTROL" );      { folder holding cluster control files for households }

  setfile( fromcheck, concat( strip(central), "\ERRORS.TXT" ) );  { file coming from StructureCheck }

PostProc
  {PostProc of level 0 }
  stop(-1);

PROC MENU_LEVEL
PreProc

  { Get the cluster, supervisor and interviewer numbers if already used before }
  setfile( state, concat( strip(central), "\state" ) );
  FileRead( state, xstate );
  today = edit("99999999",sysdate("MMDDYYYY"));
  xcluster = xstate[1:3];
  xsupnum  = xstate[5:3];

  { update control file with clusters arrived from the field }
  UpdateControlArrived();
  FindClosedClusters();

  open( INTERV );
  do j = 1 while loadcase( INTERV )     { load list of interviewers into memory }
    intvwcode(j) = ICODE;
    intvwteam(j) = ITEAM;
    intvwname(j) = INAME;
    intvwrole(j) = IROLE;
  enddo;
  totintvw = j-1;
  close( INTERV );


PROC WCLUSTER
onfocus
  if special(visualvalue($)) & tonumber(xcluster) <> 0 then
    $ = tonumber(xcluster)
  endif;

postproc
  if !loadcase( CLUSTERS, $ ) then
    errmsg( 001, WCLUSTER );
    reenter;
  endif;
  WREGIONN   = YGEO1NAME;
  WDISTRICTN = YGEO2NAME;
  WCOUNTYN    = YGEO3NAME;

  xcluster = edit( "999", WCLUSTER );                 { Cluster number }

  xparamet = "000000000000000";                    { initialize data entry parameter to zeros }
  { xparamet postions as received by the data collection applications }
  {  1:3   - interviewer number                                 }
  {  4:3   - supervisor number                                  }
  {  7:1   - modify by central office, also used by supervisors }
  {  8:1   - revisit                                            }
  {  9:1   - modify completed                                   }
  { 10:1   - if case has been saved partially                   }
  { 11:1   - enter height & weight data                         }
  { 12:3   - household number                                   }

  setfile( state, concat( strip(central), "\state" ) );
  FileCreate( state );
  FileWrite( state, xcluster );  

PROC WFINAL
  heading = concat( "Central Office Menu, Cluster: ", strip(xcluster) );
  action = accept( heading,
					"1.  Receive questionnaires",		{1}
					"2.  Household structure check",	{2}
					"3.  Secondary editing",			{3}
					"4.  View/modify questionnaires",	{4}
					"5.  Field check tables",			{5}
					"6.  Cluster status report",		{6}
					"7.  Close cluster",				{7}
					"8.  View notes",					{8}
					"9.  Change cluster",				{9}
				    "10. Back up data",					{10}					
				    "11. EXIT" );						{11}

  if action in 0,11 then stop(-1) endif;

  if action = 9 then          { change cluster number }
    reenter WCLUSTER
    

  elseif action = 1 then       { receive cluster form supervisor }
    if receive_data() = 1 then 
      updtctrl( 0 )
    endif;
    reenter WFINAL;

  elseif action = 2 then       { list questionnaires for a cluster }
    if files_in( rawdata ) then 
      if clustopen() then  
        close( fromcheck );     { it is necessary because StCheck will generate it again }
        app = "StructureCheck";
        StructureCheck( 1 );  
        runpff( 1, central );
        prepfiles( "StructureCheck.txt", "StructureCheck.wrt", concat( "S", strip(xcluster), ".ids" ), 1 );
        textview( strip(reports), concat( "S", strip(xcluster), ".ids" ) );
        FileRead( fromcheck, chkfile );
        if pos( "WITH ERRORS", chkfile ) then
          errmsg( 103 );
        else
          updtctrl( 1 );                     { update control to accept cluster }
          copyctrl( 1 );
          errmsg( 115 );
        endif
      endif
    else
      errmsg( 102 );
    endif;
    reenter WFINAL;

  elseif action = 3 then                  { run inconsistencies }
    if files_in( accepted ) then
      app = "SecondaryEditing";                     { first household }
      secondaryediting();
      runpff( 1, central );
      updtctrl( 2 );                        { update control file with secondary editing runs }
    else
      errmsg( 107, strip(accepted) );
    endif;
    reenter WFINAL;

  elseif action in 4 then                  { modify household/individual questionnaires }
    x = accept( "Type of data modification", "1 - Structural problems", "2 - Secondary editing" );
    temp = rawdata;
    if x = 2 then temp = accepted endif;
    y = 1;
    { to check if cluster closed for for both type of modifications or   }
    { already accepted or run secondary editing when structural problems }
    if !valstatus( x ) then
      y = accept( "Are you sure you want to modify the original data?", "Yes", "No" );
    endif;
    if y = 1 & files_in( temp ) then
      app = "CFTF";
      genpff( 2 );
      runpff( 2, central );
    elseif y = 1 then
      errmsg( 105, strip(temp) );
    endif;
    reenter WFINAL;

  elseif action = 5 then                 { run check field tables }
    collapse();
    app = "FieldCheck";
    FieldChk();
    runpff( 4, central );
    apptoday = concat(strip(app), "_", today);
    filecopy( concat( strip(central), "\", strip(app), ".TBD" ), concat( strip(central), "\", strip(apptoday), ".TBD" ) );
    filecopy( concat( strip(central), "\", strip(app), ".PRM" ), concat( strip(central), "\", strip(apptoday), ".PRM" ) );
    TheCommand = concat('"', strip(central), '\TablesUnicode.exe" ', strip(central), "\", strip(apptoday), ".TBD");
    ExecSystem( strip(TheCommand), nowait );      
    fname = concat( strip(central), "\", strip(apptoday), ".RTF");
    TheCommand = concat( '"C:\Program Files\Microsoft Office\root\Office16\WINWORD.EXE" ', fname ); { !! TO DO - must change file path of Office !! FABRICE }
    ExecSystem( TheCommand, wait );
    
    reenter WFINAL;

  elseif action = 6 then                  { status report }
   { filerep = accept( "Type of report desired", "By Cluster", "By Supervisor" ); { !! TO DO GD - look up what kind of status reports I agreed to }
    if filerep = 2 then
      app = "SORTCONT";
      sortcont();
      runpff( 3, central );
    endif;}
    app = "StatusReport";
    makestat( filerep );
    runpff( 1, central );
    textview( strip(reports), "StatusReport.WRT" );
    reenter WFINAL;

  elseif action = 7 then                 { close cluster }
    if valstatus( 3 ) then
      updtctrl( 3 );                      { update control file after inconsistencies are run }
      copyctrl( 2 );
    endif;
    reenter WFINAL;

  elseif action = 8 then                  { review notes for a cluster }
    if files_in( rawdata ) then
      textview( strip(rawdata), concat( "T", strip(xcluster), ".NOT" ) );
    else
      errmsg( 106, strip(rawdata) );
    endif;
    reenter WFINAL;

  elseif action = 10 then                { back-up data }
    backupf();
    reenter WFINAL;

  endif;

